# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

from typing import Union
from .CheckParam import CheckParam
from .Port import Port

class Solver:
    """This class allows to perform operations relatives to the solver.
    """
    
    def __init__(self, MWS):
        """Initializes a new instance of Solver.

        Parameters
        ----------
        MWS : COM object
            COM object referencing the project to control.
        """
        
        self.__MWS = MWS
        self.__CheckParam = CheckParam(MWS)
        self.Port = Port(MWS)
        return
    
    def setFrequencyRange(
        self, fMin: Union[float, str], fMax: Union[float, str]):
        """Adjust the frequency range for the simulation.

        Parameters
        ----------
        fMin : Union[float, str]
            Lowest frequency of the range.
        fMax : Union[float, str]
            Highest frequency of the range.

        Raises
        ------
        TypeError
            If any of the parameters (fMin, fMax) describing the frequency range
            is not of type float or str.
        RuntimeError
            If any of the parameters describing the frequency range is of type
            str but it does not match any parameter already defined in the
            project.
        RuntimeError
            If the VBA code generated by this method is not successfully executed
            by CST.
        """
        
        ########################################################################
        # Pass all the input parameters corresponding to frequency values
        # through the Parameter Checker to assess that they are of the correct
        # type and to cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        freqParams = {"fMin": fMin, "fMax": fMax}
        
        # For each parameter
        for key, value in freqParams.items():
            # Pass it through the checker
            try:
                freqParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a " + 
                                   "parameter already defined in the project")
                
        # --------------------------------------------------------------------
        
        # Generate the VBA code for adjusting the frequency range        
        vba = 'Solver.FrequencyRange "{}", "{}"'.format(freqParams["fMin"], freqParams["fMax"])

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define frequency range", vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for adjusting the frequency " +
                "range was not successful. Check that fMax is greater than fMin.")
                
        return
    
    def getSolverType(self):
        """Get the current solver for the project.

        Returns
        -------
        str
            Name of the current solver.
        """
        
        self.__MWS._FlagAsMethod("GetSolverType")
        result = self.__MWS.GetSolverType()
        
        return result
    
    def changeSolverType(self, type: str):
        """Change the solver type used in the project.
        
        Possible solver identifiers are "HF Time Domain", "HF Eigenmode", "HF
        Frequency Domain", "HF IntegralEq", "HF Multilayer", "HF Asymptotic".

        Parameters
        ----------
        type : str
            Name of the solver to use.

        Raises
        ------
        TypeError
            If type is not of type str.
        ValueError
            If type is of type str but does not correspond to a valid solver
            identifier.
        RuntimeError
            If the VBA code generated by this method is not successfully executed
            by CST.
        """
        # Check that type is of type str
        if not isinstance(type, str):
            raise TypeError("ERROR: type must be of type str.")
        
        # Check that type corresponds to a valid solver identifier
        validTypes = {
            "HF Time Domain", "HF Eigenmode", "HF Frequency Domain",
            "HF IntegralEq", "HF Multilayer", "HF Asymptotic"}
        if type not in validTypes:
            raise ValueError("ERROR: valid types values are " +
                             ", ".join(validTypes) + ".")
        
        # Generate VBA code for changing the solver type
        vba = 'ChangeSolverType "{}"'.format(type)

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("change solver type", vba)



        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for changing the solver type" +
                " was not successful.")
        
        return

    def stimulation(self, port: str, mode: str):
        """Perform a stimulation on a specified port with a given excitation mode.

        This method replicates the functionality of:
            fdSolver.Stimulation("Zmin", "TE(0,0)")
        by generating the corresponding VBA command.

        Parameters
        ----------
        port : str
            The port at which to apply the stimulation (e.g., "Zmin").
        mode : str
            The excitation mode (e.g., "TE(0,0)").

        Raises
        ------
        TypeError
            If either port or mode is not of type str.
        RuntimeError
            If the VBA code for setting the stimulation is not successfully executed by CST.
        """
        # Check that port and mode are strings
        if not isinstance(port, str):
            raise TypeError("ERROR: port must be of type str.")
        if not isinstance(mode, str):
            raise TypeError("ERROR: mode must be of type str.")

        # Generate the VBA code to set the stimulation
        vba = 'FDSolver.Stimulation "{}", "{}"'.format(port, mode)

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("set stimulation", vba)

        # Raise an exception if the code was not executed successfully
        if result != True:
            raise RuntimeError("ERROR: Execution of the VBA code for stimulation was not successful.")

        return

    def setBoundaryCondition(
        self, xMin: str, xMax: str, yMin: str, yMax: str, zMin: str, zMax: str,
        wallCond: Union[float, str] = 1000.0):
        """Sets the boundary conditions for the project.
        
        Possible values are: "electric", "magnetic", "open", "expanded open"
        (called "open add space" in CST GUI), "periodic", "conducting wall",
        "unit cell".
        
        "unit cell" can only be used for X and Y boundaries. In addition, if
        "unit cell" is used for any of the X or Y boundaries, then it must be
        used for all of them.
        
        "wallCond" can be either a numeric value or a string representing a
        parameter of the project.

        Parameters
        ----------
        xMin : str
            Boundary type for the -X boundary.
        xMax : str
            Boundary type for the +X boundary.
        yMin : str
            Boundary type for the -Y boundary.
        yMax : str
            Boundary type for the +Y boundary.
        zMin : str
            Boundary type for the -Z boundary.
        zMax : str
            Boundary type for the +Z boundary.
        wallCond : Union[float, str], optional
            Conductivity value of the boundaries of type "conducting wall", by
            default 1000.0

        Raises
        ------
        TypeError
            If any of the parameters defining the boundary types is not of type
            str.
        ValueError
            If any of the parameters defining the boundary types contains a
            string that does not correspond to a valid boundary type.
        ValueError
            If "unit cell" is specified for either zMin or zMax.
        ValueError
            If "unit cell" is specified for only some of the X and Y boundaries.
        TypeError
            If wallCond is not of type float or str.
        RuntimeError
            If wallCond is of type str but it does not match any parameter
            already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully executed
            by CST.
        """

        # Groups the specified boundary types in dictionaries to facilitate
        # their manipulation
        allBoundaries = {"xMin": xMin, "xMax": xMax, "yMin": yMin,
                         "yMax": yMax, "zMin": zMin, "zMax": zMax}
        
        xyBoundaries = {"xMin": xMin, "xMax": xMax, "yMin": yMin, "yMax": yMax}
        
        # List of valid boundary types
        validBoundaryTypes = {"electric", "magnetic", "open", "expanded open",
                              "periodic", "conducting wall", "unit cell"}
        
        #######################################################################
        # Check the validity of input parameters corresponding to the boundary
        # types
        #######################################################################
        
        # For each boundary
        for key, value in allBoundaries.items():
            
            # Check that it is of type str
            if not isinstance(allBoundaries[key], str):
                raise TypeError("ERROR: {} must be of type str.".format(key))
            
            # Check that it corresponds to a valid value
            if not value in validBoundaryTypes:
                raise ValueError("ERROR: {} does not indicate a valid " +
                                 "boundary type".format(key))
            
            # If a unit cell boundary is applied to zMin or zMax, raise an
            # exception
            if value == "unit cell":
                if key in {"zMin", "zMax"}:
                    raise ValueError("ERROR: unit cell boundary type can only" +
                                     " be applied to X and Y boundaries.")
        
        # Check if any of the X or Y boundaries is of "unit cell" type. In an
        # affirmative case, check that all of them are of this type and,
        # otherwise, raise an exception.
        if "unit cell" in xyBoundaries.values():
            if not all(aux == "unit cell" for aux in xyBoundaries.values()):
                raise ValueError(
                    "ERROR: If any of the X or Y boundaries is of type " +
                    "unit cell, then all of them must be of this same type.")
                
        # --------------------------------------------------------------------
        
        
        # Pass wallCond through the parameter checker
        try:
            wallCond = self.__CheckParam.doCheck(wallCond)
        # If an exception occurs, handle it    
        except TypeError:
            raise TypeError(f"ERROR: wallCond must be of type float or str.")
        except RuntimeError:
            raise RuntimeError(f"ERROR: wallCond must make reference to a " + 
                               "parameter already defined in the project")
            
        
        # Generate the VBA code for defining the boundary conditions

        if "expanded open" in allBoundaries.values():
            addSpaceFactorVBA = '.OpenAddSpaceFactor "0.5"\n'
        else:
            addSpaceFactorVBA = ""

        if "conducting wall" in allBoundaries.values():
            wallCondVBA = '.WallConductivity "{}"\n'.format(wallCond)
        else:
            wallCondVBA = ""

        vba = (
            'With Boundary\n' +
            '.Xmin "{}"\n'.format(xMin) +
            '.Xmax "{}"\n'.format(xMax) +
            '.Ymin "{}"\n'.format(yMin) +
            '.Ymax "{}"\n'.format(yMax) +
            '.Zmin "{}"\n'.format(zMin) +
            '.Zmax "{}"\n'.format(zMax) +
            '.ApplyInAllDirections "False"\n' +
            addSpaceFactorVBA +
            wallCondVBA +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define boundaries", vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for adjusting the boundary " +
                "conditions was not successful.")
        
        return
    
    def addSymmetryPlane(self, xSym: str, ySym: str, zSym: str):
        """Adjusts the symmetry planes for the project.
        
        Possible values are "none", "electric" and "magnetic".

        Parameters
        ----------
        xSym : str
            Symmetry type of the YZ plane.
        ySym : str
            Symmetry type of the XZ plane.
        zSym : str
            Symmetry type of the XY plane.

        Raises
        ------
        TypeError
            If any of the input parameters is not of type str.
        ValueError
            If any of the input parameters contains a non valid value.
        RuntimeError
            If the VBA code generated by this method is not successfully executed
            by CST.
        """
        
        #######################################################################
        # Check the validity of input parameters corresponding to the boundary
        # types
        #######################################################################
        
        # Group the specified symmetry types in a dictionary to facilitate their
        # manipulation
        allSyms = {"xSym": xSym, "ySym": ySym, "zSym": zSym}
        
        # List of valid boundary types
        validSymTypes = {"none", "electric", "magnetic"}
        
        # For each symmetry plane
        for key, value in allSyms.items():
            
            # Check that it is of type str
            if not isinstance(value, str):
                raise TypeError("ERROR: {} must be of type str.".format(key))
            
            # Check that it corresponds to a valid value
            if not value in validSymTypes:
                raise ValueError("ERROR: {} does not indicate a valid " +
                                 "symmetry type".format(key))
                
        # --------------------------------------------------------------------
                
        # Generate the VBA code for defining the symmetries
        vba = (
            'With Boundary\n' +
            '.Xsymmetry "{}"\n'.format(xSym) +
            '.Ysymmetry "{}"\n'.format(ySym) +
            '.Zsymmetry "{}"\n'.format(zSym) +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define boundaries", vba)

        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for adjusting the symmetry " +
                "planes was not successful.")
            
        return
    
    def addFieldMonitor(self, type: str, freq: Union[float, str]):
        """Add a field monitor to the project.
        
        Only frequency type monitors are supported.
        
        Supported field types: "Efield", "Hfield", "Farfield", "Fieldsource",
        "Surfacecurrent", "Powerflow", "Current", "Powerloss", "Eenergy",
        "Henergy"

        Parameters
        ----------
        type : str
            Type of field to be monitored.
        freq : Union[float, str]
            Frequency at which the field is monitored.

        Raises
        ------
        TypeError
            If type is not of type str.
        ValueError
            If type contains a non valid value.
        TypeError
            If freq not of type float or str.
        RuntimeError
            If freq is of type str but it does not make reference to a parameter
            already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that type is of type str
        if not isinstance(type, str):
            raise TypeError("ERROR: type must be of type str.")
        
        # List of valid monitor types
        validMonitorTypes = {
            "Efield", "Hfield", "Farfield", "Fieldsource", "Surfacecurrent",
            "Powerflow", "Current", "Powerloss", "Eenergy", "Henergy"}
        
        # Check that the specified monitor type is in the list of valid types
        if not type in validMonitorTypes:
            raise ValueError(
                "ERROR: type does not indicate a valid field monitor type")
            
        # Pass freq through the parameter checker
        try:
            freq = self.__CheckParam.doCheck(freq)
        # If an exception occurs, handle it
        except TypeError:
            raise TypeError(f"ERROR: freq must be of type float or str.")
        except RuntimeError:
            raise RuntimeError(f"ERROR: freq must make reference to a " + 
                               "parameter already defined in the project")
        
        # Generate the VBA code for creating the field monitor
        
        # Create a dictionary for retrieving the correct label for the monitor
        # from its type
        monitorTypeLabels = {
            "Efield": "e-field", "Hfield": "h-field", "Farfield": "farfield",
            "Fieldsource": "field-source", "Surfacecurrent": "surface-current",
            "Powerflow": "power", "Current": "current-density",
            "Powerloss": "loss", "Eenergy": "e-energy", "Henergy": "h-energy"
        }
        # Generate the name for the monitor
        name = monitorTypeLabels[type] + ' (f={})'.format(freq)
        vba = (
            'With Monitor\n' +
            '.Reset\n' +
            '.Name "{}"\n'.format(name) +
            '.Dimension "Volume"\n' +
            '.Domain "Frequency"\n' +
            '.FieldType "{}"\n'.format(type) +
            '.Frequency "{}"\n'.format(freq) +
            '.UseSubVolume "False"\n' +
            '.Create\n' +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define monitor: " + name, vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for creating the field " +
                "monitor was not successful.")
            
        return

    def setBackgroundMaterial(
        self, type: str, epsR: Union[float, str]=1.0,
        muR: Union[float, str]=1.0, tanD: Union[float, str]=0.0,
        tanDFreq: Union[float, str]=0.0, tanDGiven: bool=False,
        sigma: Union[float, str]=0.0, tanDM: Union[float, str]=0.0,
        tanDMFreq: Union[float, str]=0.0, tanDMGiven: bool=False,
        sigmaM: Union[float, str]=0.0):
        """Adjust the background material of the project.
        
        Three types of materials can be chosen: "Vacuum", "PEC" and
        "Dielectric".
        
        All the optional arguments must be used only if a dielectric background
        is chosen.

        Parameters
        ----------
        type : str
            Type of material to be used.
        epsR : Union[float, str], optional
            Relative electric permittivity, by default 1.0
        muR : Union[float, str], optional
            Relative magnetic permeability, by default 1.0
        tanD : Union[float, str], optional
            Electric loss tangent, by default 0.0
        tanDFreq : Union[float, str], optional
            Frequency (in Hz) at which the electric loss tangent is given, by
            default 0.0
        tanDGiven : bool, optional
            Flag to indicate whether the electric losses of the material are
            specified by the electric loss tangent (True) or the electric
            conductivity (False), by default False
        sigma : Union[float, str], optional
            Electric conductivity, by default 0.0
        tanDM : Union[float, str], optional
            Magnetic loss tangent, by default 0.0
        tanDFreq : Union[float, str], optional
            Frequency (in Hz) at which the magnetic loss tangent is given, by
            default 0.0
        tanDMGiven : bool, optional
            Flag to indicate whether the magnetic losses of the material are
            specified by the magnetic loss tangent (True) or the magnetic
            conductivity (False), by default False
        sigmaM : Union[float, str], optional
            Magnetic conductivity, by default 0.0

        Raises
        ------
        TypeError
            If type is not of type str.
        ValueError
            If type contains a non-valid value.
        TypeError
            If either tanDGiven or tanDMGiven are not of type bool.
        TypeError
            If any of the bkgrParams is not of type float or str.
        RuntimeError
            If any of the bkgrParams is of type str but it does not correspond
            to a parameter already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that type is of type str
        if not isinstance(type, str):
            raise TypeError("ERROR: type must be of type str.")
        
        # Check that type indicates a valid material type
        validMaterialTypes = {"Vacuum", "PEC", "Dielectric"}
        if not type in validMaterialTypes:
            raise ValueError(
                "ERROR: type does not indicate a valid material type.")
            
        # Check that tanDGiven and tanDMGiven are of type bool
        if not isinstance(tanDGiven, bool) or not isinstance(tanDMGiven, bool):
            raise TypeError("ERROR: tanDGiven and tanDMGiven must be if type bool.")
            
        ########################################################################
        # Pass all the input parameters corresponding to background material
        # properties through the Parameter Checker to assess that they are of
        # the correct type and to cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        bkgrParams = {"epsR": epsR, "muR": muR, "tanD": tanD,
                      "tanDFreq": tanDFreq, "sigma": sigma, "tanDM": tanDM,
                      "tanDMFreq": tanDMFreq, "sigmaM": sigmaM}
        
        # For each parameter
        for key, value in bkgrParams.items():
            # Pass it through the checker
            try:
                bkgrParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a " + 
                                   "parameter already defined in the project")
                
        # --------------------------------------------------------------------
                
        # Generate the VBA code for defining the background material
        if type == "Vacuum":
            vba = (
                'With Material\n' +
                '.Type "Normal"\n' +
                '.Colour "0.6", "0.6", "0.6"\n' +
                '.Epsilon "1"\n' +
                '.Mu "1"\n' +
                '.sigma "0.0"\n' +
                '.sigmaM "0.0"\n' +
                '.TanDGiven "False"\n' +
                '.TanDMGiven "False"\n' +
                '.ChangeBackgroundMaterial\n' +
                'End With'
                )
        elif type == "PEC":
            vba = (
                'With Material\n' +
                '.Type "PEC"\n' +
                '.Colour "0.6", "0.6", "0.6"\n' +
                '.Epsilon "1"\n' +
                '.Mu "1"\n' +
                '.ChangeBackgroundMaterial\n' +
                'End With'
                )
        else: # type == "Dielectric"
            vba = (
                'With Material\n' +
                '.Type "Normal"\n' +
                '.Colour "0.6", "0.6", "0.6"\n' +
                '.Epsilon "{}"\n'.format(bkgrParams["epsR"]) +
                '.Mu "{}"\n'.format(bkgrParams["muR"]) +
                '.TanD "{}"\n'.format(bkgrParams["tanD"]) +
                '.TanDFreq "{}"\n'.format(bkgrParams["tanDFreq"]) +
                '.TanDGiven "{}"\n'.format(tanDGiven) +
                '.sigma "{}"\n'.format(bkgrParams["sigma"]) +
                '.TanDM "{}"\n'.format(bkgrParams["tanDM"]) +
                '.TanDMFreq "{}"\n'.format(bkgrParams["tanDMFreq"]) +
                '.TanDMGiven "{}"\n'.format(tanDMGiven) +
                '.sigmaM "{}"\n'.format(bkgrParams["sigmaM"]) +
                '.ChangeBackgroundMaterial\n' +
                'End With'
                )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("set background material", vba)

        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for defining the background" +
                " material was not successful.")
        
        return
    
    def setBackgroundLimits(
        self, xMin: Union[float, str], xMax: Union[float, str],
        yMin: Union[float, str], yMax: Union[float, str],
        zMin: Union[float, str], zMax: Union[float, str]):
        """Define the background limits of the project.
        
        These limits are defined as an increment of the surrounding space over
        the minimum bounding box containing all the solids of the project. I.e.,
        if all the input parameters are set to zero, then the bounding box of
        the project will be the smallest possible. By giving to any of the input
        parameters a positive value, this bounding box can be enlarged in the
        desired direction.
        
        It should be noted that it is not possible to specify a negative value
        since the bounding box must contain all the solid in the project.

        Parameters
        ----------
        xMin : Union[float, str]
            Distance from objects to boundary in the +X direction.
        xMax : Union[float, str]
            Distance from objects to boundary in the -X direction.
        yMin : Union[float, str]
            Distance from objects to boundary in the +Y direction.
        yMax : Union[float, str]
            Distance from objects to boundary in the -Y direction.
        zMin : Union[float, str]
            Distance from objects to boundary in the +Z direction.
        zMax : Union[float, str]
            Distance from objects to boundary in the -Z direction.

        Raises
        ------
        TypeError
            If any of the input parameters is not of type float or str.
        RuntimeError
            If any of the input parameters is  of type str but it does not
            correspond to a parameter already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        ########################################################################
        # Pass all the input parameters corresponding to background limits
        # through the Parameter Checker to assess that they are of the correct
        # type and to cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        bkgrParams = {"xMin": xMin, "xMax": xMax, "yMin": yMin,
                      "yMax": yMax, "zMin": zMin, "zMax": zMax}
        
        # For each parameter
        for key, value in bkgrParams.items():
            # Pass it through the checker
            try:
                bkgrParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a " + 
                                   "parameter already defined in the project")
                
        # --------------------------------------------------------------------
        
        # Generate the VBA code for defining the background limits
        vba = (
            'With Background\n' +
            '.XminSpace "{}"\n'.format(bkgrParams["xMin"]) +
            '.XmaxSpace "{}"\n'.format(bkgrParams["xMax"]) +
            '.YminSpace "{}"\n'.format(bkgrParams["yMin"]) +
            '.YmaxSpace "{}"\n'.format(bkgrParams["yMax"]) +
            '.ZminSpace "{}"\n'.format(bkgrParams["zMin"]) +
            '.ZmaxSpace "{}"\n'.format(bkgrParams["zMax"]) +
            '.ApplyInAllDirections "False"\n' +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define background", vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for defining the background" +
                " limits was not successful. Verify that all the input " +
                "parameters are greater or equal than zero.")
            
        return
    
    def defineFloquetModes(
        self, nModes: int, theta: Union[float, str]=0.0,
        phi: Union[float, str]=0.0, forcePolar: bool=False,
        polarAngle: Union[float, str] = 0.0):
        """Defines a Floquet modes excitation for the project.
        
        It is necessary to set first unit cell boundaries for the X and Y
        limits.
        
        Parameters
        ----------
        nModes : int
            Number of Floquet modes. The same number is used for both ports.
            Must be greater than zero.
        theta : Union[float, str], optional
            Elevation angle for the incident modes. In degrees, by default 0.0
        phi : Union[float, str], optional
            Azimuth angle for the incident modes. In degrees, by default 0.0
        forcePolar : bool, optional
            Flag for overriding the variation of the polarization angle with
            phi. If set to true, the polarization will be force along the angle
            indicated by polarAngle, by default False
        polarAngle : Union[float, str], optional
            Polarization reference to be used for defining the Floquet modes it
            forcePolar is set to True. In degrees, by default 0.0

        Raises
        ------
        TypeError
            If nModes is not of type int.
        ValueError
            If nModes is not greater than zero.
        TypeError
            If forcePolar is not of type bool.
        TypeError
            If any of the portParams is not of type float or str.
        RuntimeError
            If any of the portParams is  of type str but it does not correspond
            to a parameter already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """

        # Check that nModes is of type int
        if not isinstance(nModes, int):
            raise TypeError("ERROR: nModes must be of type int.")
        
        # Check that nModes is greater than zero
        if nModes <= 0:
            raise ValueError("ERROR: nModes must be greater than zero.")
        
        # Check that forcePolar is of type bool
        if not isinstance(forcePolar, bool):
            raise TypeError("ERROR: forcePolar must be of type bool.")
        
        ########################################################################
        # Pass all the input parameters corresponding to port characteristics
        # through the Parameter Checker to assess that they are of the correct
        # type and to cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        portParams = {"theta": theta, "phi": phi, "polarAngle": polarAngle}
        
        # For each parameter
        for key, value in portParams.items():
            # Pass it through the checker
            try:
                portParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a " + 
                                   "parameter already defined in the project")
                
        # --------------------------------------------------------------------
                
        # Generate VBA code to define the Floquet port
        vba = (
            'With FloquetPort\n' +
            '.Reset\n' +
            '.SetPolarizationIndependentOfScanAnglePhi "{}", "{}"\n'.format(portParams["polarAngle"], forcePolar) +
            '.SetSortCode "+beta/pw"\n' +
            '.SetCustomizedListFlag "False"\n' +
            '.Port "Zmin"\n' +
            '.SetNumberOfModesConsidered "{:d}"\n'.format(nModes) +
            '.SetDistanceToReferencePlane "0.0"\n' +
            '.SetUseCircularPolarization "False"\n' +
            '.Port "Zmax"\n' +
            '.SetNumberOfModesConsidered "{:d}"\n'.format(nModes) +
            '.SetDistanceToReferencePlane "0.0"\n' +
            '.SetUseCircularPolarization "False"\n' +
            'End With\n'
            'With Boundary\n' +
            '.SetPeriodicBoundaryAngles "{}", "{}"\n'.format(portParams["theta"], portParams["phi"]) +
            '.SetPeriodicBoundaryAnglesDirection "outward"\n' +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define Floquet Port boundaries", vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for defining the Floquet " +
                "port was not successful.")
            
        return
    
    def runSimulation(self):
        """Run the currently active solver.
        """
        
        self.__MWS._FlagAsMethod("RunSolver")
        self.__MWS.RunSolver()
        
        return
