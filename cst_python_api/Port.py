# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

from typing import Union
from .CheckParam import CheckParam

class Port:
    """This class allows to perform operations on the ports of the project.
    """
    
    def __init__(self, MWS):
        """Initializes a new instance of Port.

        Parameters
        ----------
        MWS : COM object
            COM object referencing the project to control.
        """
        
        self.__MWS = MWS
        self.__CheckParam = CheckParam(MWS)
        return
    
    def addDiscretePort(
        self, xMin: Union[float, str], xMax: Union[float, str],
        yMin: Union[float, str], yMax: Union[float, str],
        zMin: Union[float, str], zMax: Union[float, str],
        type: str="SParameter", impedance: float=50.0, voltage: float=1.0,
        current: float=1.0, radius: float=0.0):
        """Adds a discrete port to the current project.
        
        Three different excitation types can be considered: S-Parameters,
        Voltage and current.

        Parameters
        ----------
        xMin : Union[float, str]
            X coordinate of the first point of the port.
        xMax : Union[float, str]
            X coordinate of the second point of the port.
        yMin : Union[float, str]
            Y coordinate of the first point of the port.
        yMax : Union[float, str]
            Y coordinate of the second point of the port.
        zMin : Union[float, str]
            Z coordinate of the first point of the port.
        zMax : Union[float, str]
            Z coordinate of the second point of the port.
        type : str, optional
            String indicating the type of excitation. Possible values are
            "SParameter", "Voltage" and "Current", by default "SParameter"
        impedance : float, optional
            Impedance value of the port. Only takes effect when type is
            "SParameter", by default 50.0
        voltage : float, optional
            Voltage to apply at the port. Only takes effect when type is
            "Voltage", by default 1.0
        current : float, optional
            Current to apply at the port. Only takes effect when type is
            "Current", by default 1.0
        radius : float, optional
            Radius of the port, by default 0.0

        Raises
        ------
        TypeError
            If type is not of type str.
        ValueError
            If type is different of 'SParameter', 'Voltage' or 'Current'.
        TypeError
            If impedance is not of type float.
        ValueError
            If impedance is not greater than zero.
        TypeError
            If voltage is not of type float.
        TypeError
            If current is not of type float.
        TypeError
            If radius is not of type float.
        TypeError
            If any of the parameters (xMin, xMax, yMin, yMax, zMin, zMax)
            describing the port position is not of type float or str.
        RuntimeError
            If any of the parameters describing the port position is of type str
            but it does not match any parameter already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that type is of type str
        if not isinstance(type, str):
            raise TypeError("ERROR: type must be of type str.")
        
        # Check that type presents a valid value
        validTypes = {"SParameter", "Voltage", "Current"}
        if type not in validTypes:
            raise ValueError("ERROR: type must be 'SParameter', 'Voltage' or 'Current'.")
        
        # Check that impedance is of type float
        if not isinstance(impedance, float):
            raise TypeError("ERROR: impedance must be of type float.")
        
        # Check that impedance is greater than zero
        if impedance <= 0.0:
            raise ValueError("ERROR: impedance must be greater than zero.")
        
        # Check that voltage is of type float
        if not isinstance(voltage, float):
            raise TypeError("ERROR: voltage must be of type float.")
        
        # Check that current is of type float
        if not isinstance(current, float):
            raise TypeError("ERROR: current must be of type float.")
        
        # Check that radius is of type float
        if not isinstance(radius, float):
            raise TypeError("ERROR: radius must be of type float.")
        
        ########################################################################
        # Pass all the parameters describing the port through the Parameter
        # Checker to assess that they are of the correct type and to cast them
        # to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        portParams = {"xMin": xMin, "xMax": xMax, "yMin": yMin, "yMax": yMax, 
                      "zMin": zMin, "zMax": zMax}
        
        # For each parameter
        for key, value in portParams.items():
            # Pass it through the checker
            try:
                portParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a" + 
                                   "parameter already defined in the project")
        
        # Obtain the next available port number by adding 1 to the total number
        # of ports
        portNumber = self.__MWS.Port.StartPortNumberIteration + 1
        
        # Generate the VBA code for creating the port
        vba = (
            'With DiscretePort\n' +
            '.Reset\n' +
            '.Type "{}"\n'.format(type) +
            '.PortNumber "{:d}"\n'.format(portNumber) +
            '.SetP1 "False", "{}", "{}", "{}"\n'.format(portParams["xMin"], portParams["yMin"], portParams["zMin"]) +
            '.SetP2 "False", "{}", "{}", "{}"\n'.format(portParams["xMax"], portParams["yMax"], portParams["zMax"]) +
            '.Impedance "{}"\n'.format(impedance) +
            '.Voltage "{}"\n'.format(voltage) +
            '.Current "{}"\n'.format(current) +
            '.Radius "{}"\n'.format(radius) +
            '.Create\n' +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define discrete port: {:d}".format(portNumber), vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for creating the discrete " +
                "port was not successful.")
                
        return
    
    def addWaveguidePort(
        self, xMin: Union[float, str], xMax: Union[float, str],
        yMin: Union[float, str], yMax: Union[float, str],
        zMin: Union[float, str], zMax: Union[float, str], orientation: str,
        nModes: int = 1, enforcePolar: bool = False,
        polarAngle: Union[float, str] = 0.0, refPlaneDist: Union[float, str] = 0.0):
        """Adds a waveguide port to the current project.
        
        The orientation of the port is indicated by specifying its normal vector
        (X, Y or Z). It must be noted that for each of these directions, the
        port can produce an excitation towards negative or positive values. This
        is specified with the "min" and "max" suffixes. However, it should be
        noted that the sense of this normal vector is the contrary of that of
        the waveguide excitation. This means that "xmin" specifies a port that
        produces an excitation propagating towards the direction +X. In this
        case, the boundaries of the port would be defined by yMin, yMax, zMin
        and zMax, while xMin would indicate the position along the X axis where
        the port would be placed. Please note that it would still be necessary
        to assign a value to xMax in this case, although this value will be
        unused. Conversely, "xmax" indicates a waveguide port producing an
        excitation in the -X direction.

        Parameters
        ----------
        xMin : Union[float, str]
            Smallest value of the X coordinate in the area of the port.
        xMax : Union[float, str]
            Greatest value of the X coordinate in the area of the port.
        yMin : Union[float, str]
            Smallest value of the Y coordinate in the area of the port.
        yMax : Union[float, str]
            Greatest value of the Y coordinate in the area of the port.
        zMin : Union[float, str]
            Smallest value of the Z coordinate in the area of the port.
        zMax : Union[float, str]
            Greatest value of the Z coordinate in the area of the port.
        orientation : str
            Orientation of the port. Please note that the sense of this vector
            is contrary to the sense of the excitation produced by the port.
            This means that "xmin" indicates "towards +X" and "xmax" indicates
            "towards -X". Analogous definitions for Y and Z.
        nModes : int, optional
            Number of modes to consider at the port. Must be equal or greater
            than 1, by default 1
        enforcePolar : bool, optional
            Flag indicating whether a specific polarization angle must be
            enforced. Useful when there are degenerate modes, by default False
        polarAngle : float, optional
            Polarization angle to enforce. It is necessary to activate the flag
            enforcePolar, by default 0.0
        refPlaneDist : float, optional
            Distance between the port and the reference plane for the phase of
            the S-Parameters. A negative value shifts the reference plane
            towards the direction indicated by orientation, by default 0.0

        Raises
        ------
        TypeError
            If orientation is not of type str.
        ValueError
            If orientation does not present a valid value.
        TypeError
            If nModes is not of type int.
        ValueError
            If nModes is smaller than one.
        TypeError
            If enforcePolar is not of type bool.
        TypeError
            If any of the parameters (xMin, xMax, yMin, yMax, zMin, zMax,
            polarAngle, refPlaneDist) describing the port position is not of
            type float or str.
        RuntimeError
            If any of the parameters describing the port position is of type str
            but it does not match any parameter already defined in the project.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that orientation is of type str
        if not isinstance(orientation, str):
            raise TypeError("ERROR: orientation must be of type str.")
        
        # Check that orientation presents a valid value
        validOrientations = {"xmin", "xmax", "ymin", "ymax", "zmin", "zmax"}
        if orientation not in validOrientations:
            raise ValueError("ERROR: valid orientation values are " +
                             ", ".join(validOrientations) + ".")
        
        # Depending on the chosen orientation, make xMax, yMax or zMax equal to
        # its min counterpart    
        if orientation in {"xmin", "xmax"}:
            xMax = xMin
        elif orientation in {"ymin", "ymax"}:
            yMax = yMin
        else: # zmin, zmax
            zMax = zMin
        
        # Check that nModes is of type int    
        if not isinstance(nModes, int):
            raise TypeError("ERROR: nModes must be of type int.")
        
        # Check that nModes is equal or greater than 1
        if nModes < 1:
            raise ValueError("ERROR: nModes must be equal or greater than 1.")
        
        # Check that enforcePolar is of type bool
        if not isinstance(enforcePolar, bool):
            raise TypeError("ERROR: enforcePolar must be of type bool.")
        
        ########################################################################
        # Pass all the parameters describing the port through the Parameter
        # Checker to assess that they are of the correct type and to cast them
        # to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        portParams = {"xMin": xMin, "xMax": xMax, "yMin": yMin, "yMax": yMax, 
                      "zMin": zMin, "zMax": zMax, "polarAngle": polarAngle, 
                      "refPlaneDist": refPlaneDist}
        
        # For each parameter
        for key, value in portParams.items():
            # Pass it through the checker
            try:
                portParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a" + 
                                   "parameter already defined in the project")
        
        # Obtain the next available port number by adding 1 to the total number
        # of ports
        portNumber = self.__MWS.Port.StartPortNumberIteration + 1
        
        # Generate the VBA code for creating the port
        vba = (
            'With Port\n' +
            '.Reset\n' +
            '.PortNumber "{:d}"\n'.format(portNumber) +
            '.Label ""\n' +
            '.Folder ""\n' +
            '.NumberOfModes "{:d}"\n'.format(nModes) +
            '.AdjustPolarization {}\n'.format(enforcePolar) +
            '.PolarizationAngle "{}"\n'.format(portParams["polarAngle"]) +
            '.ReferencePlaneDistance "{}"\n'.format(portParams["refPlaneDist"]) +
            '.TextSize "50"\n' +
            '.TextMaxLimit "1"\n' +
            '.Coordinates "Free"\n' +
            '.Orientation "{}"\n'.format(orientation) +
            '.PortOnBound "False"\n' +
            '.ClipPickedPortToBound "False"\n' +
            '.Xrange "{}", "{}"\n'.format(portParams["xMin"], portParams["xMax"]) +
            '.Yrange "{}", "{}"\n'.format(portParams["yMin"], portParams["yMax"]) +
            '.Zrange "{}", "{}"\n'.format(portParams["zMin"], portParams["zMax"]) +
            '.XrangeAdd "0.0", "0.0"\n' +
            '.YrangeAdd "0.0", "0.0"\n' +
            '.ZrangeAdd "0.0", "0.0"\n' +
            '.SingleEnded "False"\n' +
            '.WaveguideMonitor "False"\n' +
            '.Create\n' +
            'End With'
            )

        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("define waveguide port: {:d}".format(portNumber), vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for creating the discrete " +
                "port was not successful. Check that polarAngle takes a value" +
                "in the interval [0.0, 360.0].")
                
        return