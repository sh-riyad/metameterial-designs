# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

from typing import Union
from .CheckParam import CheckParam
from .Component import Component

class Transform:
    """This class allows to perform transformations on objects of the
    project.
    """
    
    def __init__(self, MWS):
        """Initializes a new instance of Transform.

        Parameters
        ----------
        MWS : COM object
            COM object referencing the project to control.
        """
        
        self.__MWS = MWS
        self.__CheckParam = CheckParam(MWS)
        self.__Component = Component(MWS)
        return
    
    def translate(
        self, object: str, x: Union[float, str], y: Union[float, str],
        z: Union[str, float], copy: bool=False, repetitions: int=1, group=False,
        destination: str="", material: str=""):
        """Translates an object.

        Parameters
        ----------
        object : str
            Name of the object on which to perform the operation.
        x : Union[float, str]
            Translation distance along axis X.
        y : Union[float, str]
            Translation distance along axis Y.
        z : Union[str, float]
            Translation distance along axis Z.
        copy : bool, optional
            Flag to indicate if the operation must be applied to a duplicate of
            the object, by default False
        repetitions : int, optional
            Number of times that the operation must be applied, by default 1
        group : bool, optional
            In case of copy=True, if this flag is set to True, the original
            objects and its replica(s) will be joined, by default False
        destination : str, optional
            In case of copy=True, indicates the destination name for the copy.
            If nothing is specified the default value will be used, by default
            ""
        material : str, optional
            In case of copy=True, indicates the material to be used for the
            copy. If nothing is specified the same material as in the original
            value will be used, by default ""

        Raises
        ------
        TypeError
            If object is not of type str.
        TypeError
            If copy is not of type bool.
        TypeError
            If repetitions is not of type int.
        ValueError
            If repetitions is smaller than 1.
        TypeError
            If group is not of type bool.
        TypeError
            If destination is not of type str.
        TypeError
            If material is not of type str.
        ValueError
            If group is True but copy is False.
        ValueError
            If destination is not empty but copy is False.
        ValueError
            If material is not empty but copy is False.
        TypeError
            If any of the transformation parameters (x, y, z) describing the
            translation is not of type float or str.
        RuntimeError
            If any of the transformation parameters describing the translation
            is of type str but it does not match any parameter already defined
            in the project.
        RuntimeError
            If calling to the ensureExistence() method raises a RuntimeError.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that object is of type str
        if not isinstance(object, str):
            raise TypeError("ERROR: object must be of type str.")
        
        # Check that copy is of type bool
        if not isinstance(copy, bool):
            raise TypeError("ERROR: copy must be of type bool.")
        
        # Check that repetitions is of type int and greater than 0.
        if not isinstance(repetitions, int):
            raise TypeError("ERROR: repetitions must be of type int.")
        elif repetitions < 1:
            raise ValueError("ERROR: repetitions must be equal or greater than 1.")
        
        # Check that group is of type bool
        if not isinstance(group, bool):
            raise TypeError("ERROR: group must be of type bool.")
        
        # Check that destination is of type str
        if not isinstance(destination, str):
            raise TypeError("ERROR: destination must be of type str.")
        
        # Check that material is of type str
        if not isinstance(material, str):
            raise TypeError("ERROR: material must be of type str.")
        
        # If no copy of the object is to be made, then group, destination and
        # material must have their default values
        if copy == False:
            if group == True:
                raise ValueError("ERROR: If copy=False, then group must be False too.")
            elif destination != "":
                raise ValueError("ERROR: If copy=False, then destination must be an empty string.")
            elif material != "":
                raise ValueError("ERROR: If copy=False, then material must be an empty string.")
        
        ########################################################################
        # Pass all the parameters describing the translation through the
        # Parameter Checker to asses that they are of the correct type and to
        # cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        tranParams = {"x": x, "y": y, "z": z}
        
        # For each parameter
        for key, value in tranParams.items():
            # Pass is through the checker
            try:
                tranParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a" + 
                                   "parameter already defined in the project")
        
        # If a destination component is specified check if it exists. If it does
        # not, create it.
        if destination != "":
            try:
                self.__Component.ensureExistence(destination)
            except RuntimeError:
                raise RuntimeError(
                    "ERROR: Creating a new component called {}".format(object) +
                    " was not possible. Check that the name does not contain " +
                    "any special characters.")
        
        # Generate VBA code for the translation operation
        vba = (
            'With Transform\n' +
            '.Reset \n' +
            '.Name "{}"\n'.format(object) +
            '.Vector "{}", "{}", "{}"\n'.format(tranParams["x"], tranParams["y"], tranParams["z"]) +
            '.UsePickedPoints "False"\n' +
            '.InvertPickedPoints "False"\n' +
            '.MultipleObjects "{}"\n'.format(copy) +
            '.GroupObjects "{}"\n'.format(group) +
            '.Repetitions "{:d}"\n'.format(repetitions) +
            '.MultipleSelection "False"\n' +
            '.Destination "{}"\n'.format(destination) +
            '.Material "{}"\n'.format(material) +
            '.Transform "Shape", "Translate"\n' +
            'End With'
            )
        
        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("transform: translate " + object, vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for translating {}".format(object) +
                " was not successful.")

        return
    
    def scale(
        self, object: str, x: Union[float, str], y: Union[float, str],
        z: Union[str, float], x0: Union[float, str]=0.0,
        y0: Union[float, str]=0.0, z0: Union[float, str]=0.0,
        origin: str="object", copy: bool=False, repetitions: int=1, group=False,
        destination: str="", material: str=""):
        """Scales an object.

        Parameters
        ----------
        object : str
            Name of the object on which to perform the operation.
        x : Union[float, str]
            Scaling factor along axis X.
        y : Union[float, str]
            Scaling factor along axis Y.
        z : Union[str, float]
            Scaling factor along axis Z.
        x0 : Union[float, str], optional
            X coordinate of origin for scaling, by default 0.0
        y0 : Union[float, str], optional
            Y coordinate of origin for scaling, by default 0.0
        z0 : Union[float, str], optional
            Z coordinate of origin for scaling, by default 0.0
        origin : str, optional
            Indicates whether the origin for the scaling operation is the center
            of the object ("object") or the point indicated by x0, y0 and z0
            ("free"), by default "object"
        copy : bool, optional
            Flag to indicate if the operation must be applied to a duplicate of
            the object, by default False
        repetitions : int, optional
            Number of times that the operation must be applied, by default 1
        group : bool, optional
            In case of copy=True, if this flag is set to True, the original
            objects and its replica(s) will be joined, by default False
        destination : str, optional
            In case of copy=True, indicates the destination name for the copy.
            If nothing is specified the default value will be used, by default
            ""
        material : str, optional
            In case of copy=True, indicates the material to be used for the
            copy. If nothing is specified the same material as in the original
            value will be used, by default ""

        Raises
        ------
        TypeError
            If object is not of type str.
        TypeError
            If origin is not of type str.
        ValueError
            If origin is different of 'object' or 'free'.
        TypeError
            If copy is not of type bool.
        TypeError
            If repetitions is not of type int.
        ValueError
            If repetitions is smaller than 1.
        TypeError
            If group is not of type bool.
        TypeError
            If destination is not of type str.
        TypeError
            If material is not of type str.
        ValueError
            If group is True but copy is False.
        ValueError
            If destination is not empty but copy is False.
        ValueError
            If material is not empty but copy is False.
        TypeError
            If any of the transformation parameters (x, y, z, x0, y0, z0)
            describing the scaling is not of type float or str.
        RuntimeError
            If any of the transformation parameters describing the scaling is of
            type str but it does not match any parameter already defined in the
            project.
        RuntimeError
            If calling to the ensureExistence() method raises a RuntimeError.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that object is of type str
        if not isinstance(object, str):
            raise TypeError("ERROR: object must be of type str.")
        
        # Check that origin is of type str
        if not isinstance(origin, str):
            raise TypeError("ERROR: origin must be of type str.")
        
        # Check that origin is either "free" or "object"
        validOrigins = {"free", "object"}
        if origin not in validOrigins:
            raise ValueError("ERROR: origin must be 'free' or 'object'.")
        
        # Check that copy is of type bool
        if not isinstance(copy, bool):
            raise TypeError("ERROR: copy must be of type bool.")
        
        # Check that repetitions is of type int and greater than 0.
        if not isinstance(repetitions, int):
            raise TypeError("ERROR: repetitions must be of type int.")
        elif repetitions < 1:
            raise ValueError("ERROR: repetitions must be equal or greater than 1.")
        
        # Check that group is of type bool
        if not isinstance(group, bool):
            raise TypeError("ERROR: group must be of type bool.")
        
        # Check that destination is of type str
        if not isinstance(destination, str):
            raise TypeError("ERROR: destination must be of type str.")
        
        # Check that material is of type str
        if not isinstance(material, str):
            raise TypeError("ERROR: material must be of type str.")
        
        # If no copy of the object is to be made, then group, destination and
        # material must have their default values
        if copy == False:
            if group == True:
                raise ValueError("ERROR: If copy=False, then group must be False too.")
            elif destination != "":
                raise ValueError("ERROR: If copy=False, then destination must be an empty string.")
            elif material != "":
                raise ValueError("ERROR: If copy=False, then material must be an empty string.")
        
        ########################################################################
        # Pass all the parameters describing the scaling through the
        # Parameter Checker to asses that they are of the correct type and to
        # cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        tranParams = {"x": x, "y": y, "z": z, "x0": x0, "y0": y0, "z0": z0}
        
        # For each parameter
        for key, value in tranParams.items():
            # Pass is through the checker
            try:
                tranParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a" + 
                                   "parameter already defined in the project")
        
        # If a destination component is specified check if it exists. If it does
        # not, create it.
        if destination != "":
            try:
                self.__Component.ensureExistence(destination)
            except RuntimeError:
                raise RuntimeError(
                    "ERROR: Creating a new component called {}".format(object) +
                    " was not possible. Check that the name does not contain " +
                    "any special characters.")
        
        # Generate VBA code for the scaling operation
        
        # Generate a different origin statement depending on the chosen option
        if origin == "object":
            originVBA = '.Origin "CommonCenter"\n'
        else:
            originVBA = '.Origin "Free"\n'
        vba = (
            'With Transform\n' +
            '.Reset\n' +
            '.Name "{}"\n'.format(object) +
            originVBA +
            '.Center "{}", "{}", "{}"\n'.format(tranParams["x0"], tranParams["y0"], tranParams["z0"]) +
            '.ScaleFactor "{}", "{}", "{}"\n'.format(tranParams["x"], tranParams["y"], tranParams["z"]) +
            '.MultipleObjects "{}"\n'.format(copy) +
            '.GroupObjects "{}"\n'.format(group) +
            '.Repetitions "{:d}"\n'.format(repetitions) +
            '.MultipleSelection "False"\n' +
            '.Destination "{}"\n'.format(destination) +
            '.Material "{}"\n'.format(material) +
            '.Transform "Shape", "Scale"\n' +
            'End With'
            )
        
        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("transform: scale " + object, vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for scaling {}".format(object) +
                " was not successful. Check that the scaling factor is not negative.")

        return
    
    def rotate(self, object: str, x: Union[float, str], y: Union[float, str],
               z: Union[str, float], x0: Union[float, str]=0.0,
               y0: Union[float, str]=0.0, z0: Union[float, str]=0.0,
               origin: str="object", copy: bool=False, repetitions: int=1,
               group=False, destination: str="", material: str=""):
        """Rotates an object.

        Parameters
        ----------
        object : str
            Name of the object on which to perform the operation.
        x : Union[float, str]
            Rotating angle (in degrees) around axis X.
        y : Union[float, str]
            Rotating angle (in degrees) around axis Y.
        z : Union[str, float]
            Rotating angle (in degrees) around axis Z.
        x0 : Union[float, str], optional
            X coordinate of origin for rotation, by default 0.0
        y0 : Union[float, str], optional
            Y coordinate of origin for rotation, by default 0.0
        z0 : Union[float, str], optional
            Z coordinate of origin for rotation, by default 0.0
        origin : str, optional
            Indicates whether the origin for the rotation operation is the
            center of the object ("object") or the point indicated by x0, y0 and
            z0 ("free"), by default "object"
        copy : bool, optional
            Flag to indicate if the operation must be applied to a duplicate of
            the object, by default False
        repetitions : int, optional
            Number of times that the operation must be applied, by default 1
        group : bool, optional
            In case of copy=True, if this flag is set to True, the original
            objects and its replica(s) will be joined, by default False
        destination : str, optional
            In case of copy=True, indicates the destination name for the copy.
            If nothing is specified the default value will be used, by default
            ""
        material : str, optional
            In case of copy=True, indicates the material to be used for the
            copy. If nothing is specified the same material as in the original
            value will be used, by default ""

        Raises
        ------
        TypeError
            If object is not of type str.
        TypeError
            If origin is not of type str.
        ValueError
            If origin is different of 'object' or 'free'.
        TypeError
            If copy is not of type bool.
        TypeError
            If repetitions is not of type int.
        ValueError
            If repetitions is smaller than 1.
        TypeError
            If group is not of type bool.
        TypeError
            If destination is not of type str.
        TypeError
            If material is not of type str.
        ValueError
            If group is True but copy is False.
        ValueError
            If destination is not empty but copy is False.
        ValueError
            If material is not empty but copy is False.
        TypeError
            If any of the transformation parameters (x, y, z, x0, y0, z0)
            describing the rotation is not of type float or str.
        RuntimeError
            If any of the transformation parameters describing the rotation is
            of type str but it does not match any parameter already defined in
            the project.
        RuntimeError
            If calling to the ensureExistence() method raises a RuntimeError.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that object is of type str
        if not isinstance(object, str):
            raise TypeError("ERROR: object must be of type str.")
        
        # Check that origin is of type str
        if not isinstance(origin, str):
            raise TypeError("ERROR: origin must be of type str.")
        
        # Check that origin is either "free" or "object"
        validOrigins = {"free", "object"}
        if origin not in validOrigins:
            raise ValueError("ERROR: origin must be 'free' or 'object'.")
        
        # Check that copy is of type bool
        if not isinstance(copy, bool):
            raise TypeError("ERROR: copy must be of type bool.")
        
        # Check that repetitions is of type int and greater than 0.
        if not isinstance(repetitions, int):
            raise TypeError("ERROR: repetitions must be of type int.")
        elif repetitions < 1:
            raise ValueError("ERROR: repetitions must be equal or greater than 1.")
        
        # Check that group is of type bool
        if not isinstance(group, bool):
            raise TypeError("ERROR: group must be of type bool.")
        
        # Check that destination is of type str
        if not isinstance(destination, str):
            raise TypeError("ERROR: destination must be of type str.")
        
        # Check that material is of type str
        if not isinstance(material, str):
            raise TypeError("ERROR: material must be of type str.")
        
        # If no copy of the object is to be made, then group, destination and
        # material must have their default values
        if copy == False:
            if group == True:
                raise ValueError("ERROR: If copy=False, then group must be False too.")
            elif destination != "":
                raise ValueError("ERROR: If copy=False, then destination must be an empty string.")
            elif material != "":
                raise ValueError("ERROR: If copy=False, then material must be an empty string.")
        
        ########################################################################
        # Pass all the parameters describing the scaling through the
        # Parameter Checker to asses that they are of the correct type and to
        # cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        tranParams = {"x": x, "y": y, "z": z, "x0": x0, "y0": y0, "z0": z0}
        
        # For each parameter
        for key, value in tranParams.items():
            # Pass is through the checker
            try:
                tranParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a" + 
                                   "parameter already defined in the project")
        
        # If a destination component is specified check if it exists. If it does
        # not, create it.
        if destination != "":
            try:
                self.__Component.ensureExistence(destination)
            except RuntimeError:
                raise RuntimeError(
                    "ERROR: Creating a new component called {}".format(object) +
                    " was not possible. Check that the name does not contain " +
                    "any special characters.")
        
        # Generate VBA code for the rotation operation
        
        # Generate a different origin statement depending on the chosen option
        if origin == "object":
            originVBA = '.Origin "CommonCenter"\n'
        else:
            originVBA = '.Origin "Free"\n'
        vba = (
            'With Transform\n' +
            '.Reset\n' +
            '.Name "{}"\n'.format(object) +
            originVBA +
            '.Center "{}", "{}", "{}"\n'.format(tranParams["x0"], tranParams["y0"], tranParams["z0"]) +
            '.Angle "{}", "{}", "{}"\n'.format(tranParams["x"], tranParams["y"], tranParams["z"]) +
            '.MultipleObjects "{}"\n'.format(copy) +
            '.GroupObjects "{}"\n'.format(group) +
            '.Repetitions "{:d}"\n'.format(repetitions) +
            '.MultipleSelection "False"\n' +
            '.Destination "{}"\n'.format(destination) +
            '.Material "{}"\n'.format(material) +
            '.Transform "Shape", "Rotate"\n' +
            'End With'
            )
        
        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("transform: rotate " + object, vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for rotating {}".format(object) +
                " was not successful.")
        return
    
    def mirror(self, object: str, x: Union[float, str], y: Union[float, str],
               z: Union[str, float], x0: Union[float, str]=0.0,
               y0: Union[float, str]=0.0, z0: Union[float, str]=0.0,
               origin: str="object", copy: bool=False, repetitions: int=1,
               group=False, destination: str="", material: str=""):
        """Mirrors an object.

        Parameters
        ----------
        object : str
            Name of the object on which to perform the operation.
        x : Union[float, str]
            X component of mirror plane normal.
        y : Union[float, str]
            Y component of mirror plane normal.
        z : Union[str, float]
            Z component of mirror plane normal.
        x0 : Union[float, str], optional
            X coordinate of mirror plane origin, by default 0.0
        y0 : Union[float, str], optional
            Y coordinate of mirror plane origin, by default 0.0
        z0 : Union[float, str], optional
            Z coordinate of mirror plane origin, by default 0.0
        origin : str, optional
            Indicates whether the origin of the mirror plane is at the the
            center of the object ("object") or at the point indicated by x0, y0
            and z0 ("free"), by default "object"
        copy : bool, optional
            Flag to indicate if the operation must be applied to a duplicate of
            the object, by default False
        repetitions : int, optional
            Number of times that the operation must be applied, by default 1
        group : bool, optional
            In case of copy=True, if this flag is set to True, the original
            objects and its replica(s) will be joined, by default False
        destination : str, optional
            In case of copy=True, indicates the destination name for the copy.
            If nothing is specified the default value will be used, by default
            ""
        material : str, optional
            In case of copy=True, indicates the material to be used for the
            copy. If nothing is specified the same material as in the original
            value will be used, by default ""

        Raises
        ------
        TypeError
            If object is not of type str.
        TypeError
            If origin is not of type str.
        ValueError
            If origin is different of 'object' or 'free'.
        TypeError
            If copy is not of type bool.
        TypeError
            If repetitions is not of type int.
        ValueError
            If repetitions is smaller than 1.
        TypeError
            If group is not of type bool.
        TypeError
            If destination is not of type str.
        TypeError
            If material is not of type str.
        ValueError
            If group is True but copy is False.
        ValueError
            If destination is not empty but copy is False.
        ValueError
            If material is not empty but copy is False.
        TypeError
            If any of the transformation parameters (x, y, z, x0, y0, z0)
            describing the mirroring is not of type float or str.
        RuntimeError
            If any of the transformation parameters describing the rotation is
            of type str but it does not match any parameter already defined in
            the project.
        RuntimeError
            If calling to the ensureExistence() method raises a RuntimeError.
        RuntimeError
            If the VBA code generated by this method is not successfully
            executed by CST.
        """
        
        # Check that object is of type str
        if not isinstance(object, str):
            raise TypeError("ERROR: object must be of type str.")
        
        # Check that origin is of type str
        if not isinstance(origin, str):
            raise TypeError("ERROR: origin must be of type str.")
        
        # Check that origin is either "free" or "object"
        validOrigins = {"free", "object"}
        if origin not in validOrigins:
            raise ValueError("ERROR: origin must be 'free' or 'object'.")
        
        # Check that copy is of type bool
        if not isinstance(copy, bool):
            raise TypeError("ERROR: copy must be of type bool.")
        
        # Check that repetitions is of type int and greater than 0.
        if not isinstance(repetitions, int):
            raise TypeError("ERROR: repetitions must be of type int.")
        elif repetitions < 1:
            raise ValueError("ERROR: repetitions must be equal or greater than 1.")
        
        # Check that group is of type bool
        if not isinstance(group, bool):
            raise TypeError("ERROR: group must be of type bool.")
        
        # Check that destination is of type str
        if not isinstance(destination, str):
            raise TypeError("ERROR: destination must be of type str.")
        
        # Check that material is of type str
        if not isinstance(material, str):
            raise TypeError("ERROR: material must be of type str.")
        
        # If no copy of the object is to be made, then group, destination and
        # material must have their default values
        if copy == False:
            if group == True:
                raise ValueError("ERROR: If copy=False, then group must be False too.")
            elif destination != "":
                raise ValueError("ERROR: If copy=False, then destination must be an empty string.")
            elif material != "":
                raise ValueError("ERROR: If copy=False, then material must be an empty string.")
        
        ########################################################################
        # Pass all the parameters describing the scaling through the
        # Parameter Checker to asses that they are of the correct type and to
        # cast them to str.
        ########################################################################
        
        # Group the values in a dictionary to simplify checking several
        # parameters
        tranParams = {"x": x, "y": y, "z": z, "x0": x0, "y0": y0, "z0": z0}
        
        # For each parameter
        for key, value in tranParams.items():
            # Pass is through the checker
            try:
                tranParams[key] = self.__CheckParam.doCheck(value)
            # If an exception occurs, handle it    
            except TypeError:
                raise TypeError(f"ERROR: {key} must be of type float or str.")
            except RuntimeError:
                raise RuntimeError(f"ERROR: {key} must make reference to a" + 
                                   "parameter already defined in the project")
        
        # If a destination component is specified check if it exists. If it does
        # not, create it.
        if destination != "":
            try:
                self.__Component.ensureExistence(destination)
            except RuntimeError:
                raise RuntimeError(
                    "ERROR: Creating a new component called {}".format(object) +
                    " was not possible. Check that the name does not contain " +
                    "any special characters.")
        
        # Generate VBA code for the mirroring operation
        
        # Generate a different origin statement depending on the chosen option
        if origin == "object":
            originVBA = '.Origin "CommonCenter"\n'
        else:
            originVBA = '.Origin "Free"\n'
        vba = (
            'With Transform\n' +
            '.Reset\n' +
            '.Name "{}"\n'.format(object) +
            originVBA +
            '.Center "{}", "{}", "{}"\n'.format(tranParams["x0"], tranParams["y0"], tranParams["z0"]) +
            '.PlaneNormal "{}", "{}", "{}"\n'.format(tranParams["x"], tranParams["y"], tranParams["z"]) +
            '.MultipleObjects "{}"\n'.format(copy) +
            '.GroupObjects "{}"\n'.format(group) +
            '.Repetitions "{:d}"\n'.format(repetitions) +
            '.MultipleSelection "False"\n' +
            '.Destination "{}"\n'.format(destination) +
            '.Material "{}"\n'.format(material) +
            '.Transform "Shape", "Mirror"\n' +
            'End With'
            )
        
        # Send the VBA code to CST
        self.__MWS._FlagAsMethod("AddToHistory")
        result = self.__MWS.AddToHistory("transform: mirror " + object, vba)
        
        # Raise an exception if the code is not executed successfully.
        if result != True:
            raise RuntimeError(
                "ERROR: Execution of the VBA code for mirroring {}".format(object) +
                " was not successful.")
        return